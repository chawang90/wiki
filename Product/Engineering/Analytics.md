# Analytics

This document outlines how we're using Segment.com for event tracking.

## The Ruby Client

There's a hand-rolled `ThirdParty::Analytics` client available everywhere in the Ruby app. It wraps the underlying Segment ruby client for convenience and flexibility. It currently supports three methods.

#### `track`

This the method that will be used most often, because the JS client is taking care of the rest.

```ruby
ThirdParty::Analytics.track(user_id, event_name, properties)
```

This is shorthand for the underlying Segment client's `track` method which uses named properties:

```ruby
ThirdParty::Analytics.track(
  user_id: user_id,
  event_name: event_name,
  properties: properties
)
```

#### `page`

The page method lets you record page views on your website, along with optional extra information about the page being viewed. Page calls are already tracked by the JS client, so this method will probably not be needed much in ruby land.

This method is just a delayed-job wrapper around Segment's `page` method: https://segment.com/docs/libraries/ruby/#page

#### `identify`

This method identifies the user. The JS client calls this method from the browser on every request, so it's generally not necessary to use it in ruby land.

This method is just a delayed-job wrapper around Segment's `identify` method: https://segment.com/docs/libraries/ruby/#identify

## The JavaScript Client

The browser-side client gives us a lot for free. It automatically sends `identify` events to Segment on every page view, and it parses `utm` query parameters and adds them to the `context` payload.

`Josephine.Analytics` is responsible for reporting page views. On every page load, it looks
for HTML `<meta>` tags containing supplementary information to pass along to segment. For example:

```html
<meta name="analytics:cookId" value="123">
<meta name="analytics:cookName" value="Julia Child">
```

If this metadata is present, great! If not, the page view is still be reported. The Segment client is smart enough to include things like URL, page title, etc by default.

There's a ruby helper for generating the meta tags that the JS client will detect and send automatically. It converts symbols to camelCase keys automatically.

```erb
<% content_for :head do %>
  <%= analytics_meta_tag(:meal_id, @meal.id) %>
  <%= analytics_meta_tag(:meal_title, @meal.title) %>
  <%= analytics_meta_tag(:cook_id, @meal.cook.id) %>
  <%= analytics_meta_tag(:cook_name, @meal.cook.full_name) %>
<% end %>
```

## Enabling Tracking

To enable Segment tracking, set the following environment variables:

- `SEGMENT_WRITE_KEY` - Use this write key to send data. The write key is synonymous with the API key and secret.
- `SEGMENT_READ_KEY` - Use this read key to get data. (Currently unused)
- `SEGMENT_ENABLED` - Set to `true` to enable tracking. If the value is absent or set to anything other than `true`, the JS client is not be injected into pages and the ruby client will initialize in `stub` mode.

## Development and Test

The ruby client initializes in `stub` mode. It logs events instead of sending them over the network.

Events are fired right away. They are not queued as delayed jobs.

To view events in development and test, tail the logs:

```
tail -f log/*.log | grep "stubbed request"
```

## Staging and Production

Events generated by the ruby client are queued as delayed jobs.

Events can be viewed in realtime:

- https://segment.com/josephine/www-staging/debugger
- https://segment.com/josephine/www-production/debugger

## Implicit Reporting of Server Events

Some server-side events that don't require extra metadata are tracked automatically. See [app/controllers/concerns/analytics_tracker.rb](app/controllers/concerns/analytics_tracker.rb).

## Attribution Source

This is a historical thing, and is not directly related to the Segment integration. Says @talsafran:

> This was added when we had greg initially plumb our analytics. If a url has `?s=charley_email_signature`, then we store in the session that a user's first visit was from clicking on charleys email sig. for example. Then in the `RSVPs` table we append the source. Could make a call to take it out though i don't see too much harm in keeping it for now.
